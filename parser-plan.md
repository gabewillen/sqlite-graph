# Parser Plan

## 1. Objective
To develop a parser that consumes the token stream generated by the lexer and constructs an Abstract Syntax Tree (AST) representing the Cypher query.

## 2. Design Considerations
*   **Input:** A stream of `CypherToken` objects from the lexer.
*   **Output:** A `CypherAst` (Abstract Syntax Tree) representing the parsed query.
*   **Parsing Strategy:** Recursive Descent Parsing (preferred due to previous Lemon issues and for better control/debugging).
    *   Alternatively, if `lemon` is to be used, the plan would focus on refining `cypher.lemon` and generating the parser.
*   **Error Handling:** Report syntax errors with meaningful messages, including line and column numbers.
*   **AST Construction:** Each grammar rule will be responsible for constructing its corresponding AST node(s).

## 3. Parser Functions (`src/cypher/cypher-parser.c`)

### `CypherParser *cypherParserCreate(void)`
*   Initializes a new parser instance.
*   Allocates memory for `CypherParser`.

### `void cypherParserDestroy(CypherParser *pParser)`
*   Frees all allocated memory associated with the parser, including the AST.

### `CypherAst *cypherParse(CypherParser *pParser, const char *zQuery, char **pzErrMsg)`
*   Main parsing function.
*   Creates a `CypherLexer` instance.
*   Iterates through tokens, calling appropriate parsing functions based on grammar rules.
*   Builds the AST incrementally.
*   Returns the root of the AST on success, NULL on failure, and sets `pzErrMsg`.

### Recursive Descent Parsing Functions (Internal)
Each function will correspond to a grammar rule (e.g., `parseQuery`, `parseMatchClause`, `parseExpression`).
*   `CypherAst *parseQuery(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseSingleQuery(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseReadingClauseList(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseMatchClause(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parsePatternList(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parsePattern(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseNodePattern(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseNodeLabels(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseRelationshipPattern(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseWhereClause(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseReturnClause(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseProjectionList(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseProjectionItem(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseOrderByClause(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseSortList(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseSortItem(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseLimitClause(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseSkipClause(CypherLexer *pLexer, CypherParser *pParser)`
*   `CypherAst *parseExpression(CypherLexer *pLexer, CypherParser *pParser)`
*   ... (and other expression parsing functions like `parseOrExpression`, `parseAndExpression`, etc.)

### Helper Functions (Internal)
*   `CypherToken *parserConsumeToken(CypherLexer *pLexer, CypherTokenType expectedType)`: Consumes the next token if it matches `expectedType`, otherwise sets error.
*   `CypherToken *parserPeekToken(CypherLexer *pLexer)`: Peeks at the next token without consuming.
*   `void parserSetError(CypherParser *pParser, CypherLexer *pLexer, const char *zFormat, ...)`: Sets an error message for the parser.

## 4. TODOs
- [ ] Define `CypherParser` struct in `include/cypher.h`.
- [ ] Implement `cypherParserCreate` in `src/cypher/cypher-parser.c`.
- [ ] Implement `cypherParserDestroy` in `src/cypher/cypher-parser.c`.
- [ ] Implement `parserConsumeToken` and `parserPeekToken`.
- [ ] Implement `parserSetError`.
- [ ] Implement `cypherParse` to drive the parsing process.
- [ ] Implement recursive descent functions for all grammar rules defined in `grammar/cypher.lemon` (or a simplified subset if a full grammar is too complex for manual parsing).
    - [ ] `parseQuery`
    - [ ] `parseSingleQuery`
    - [ ] `parseReadingClauseList`
    - [ ] `parseMatchClause`
    - [ ] `parsePatternList`
    - [ ] `parsePattern`
    - [ ] `parseNodePattern`
    - [ ] `parseNodeLabels`
    - [ ] `parseRelationshipPattern`
    - [ ] `parseWhereClause`
    - [ ] `parseReturnClause`
    - [ ] `parseProjectionList`
    - [ ] `parseProjectionItem`
    - [ ] `parseOrderByClause`
    - [ ] `parseSortList`
    - [ ] `parseSortItem`
    - [ ] `parseLimitClause`
    - [ ] `parseSkipClause`
    - [ ] `parseExpression` (and sub-expressions: `or_expression`, `and_expression`, `equality_expression`, `relational_expression`, `additive_expression`, `multiplicative_expression`, `unary_expression`, `primary_expression`, `property_expression`, `literal`)
- [ ] Add unit tests for parser functionalities (valid queries, syntax errors, edge cases).
- [ ] Ensure proper memory management (allocating and freeing AST nodes).
