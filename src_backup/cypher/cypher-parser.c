/*
** SQLite Graph Database Extension - Cypher Parser Implementation
**
** This file implements the parser infrastructure for the openCypher
** query language. It integrates the lexer and Lemon-generated parser
** to produce abstract syntax trees from Cypher query text.
**
** Features:
** - Integration with SQLite extension framework
** - Memory management following SQLite patterns
** - Detailed error reporting with line/column information
** - Reentrant parser support for multiple concurrent queries
** - Parse tree validation and semantic checking
**
** Memory allocation: All functions use sqlite3_malloc()/sqlite3_free()
** Error handling: Functions return SQLite error codes
*/

#include "sqlite3ext.h"
SQLITE_EXTENSION_INIT1
#include "cypher.h"
#include <string.h>
#include <assert.h>

/* Include generated parser */
#include "cypher-parser-generated.h"

/* Forward declarations for generated parser functions */
void *ParseAlloc(void *(*mallocProc)(int));
void ParseFree(void *p, void (*freeProc)(void*));
void Parse(void *yyp, int yymajor, CypherToken *yyminor, void *pState);

/*
** Forward declarations for Lemon-generated parser functions.
** These will be generated when the grammar is compiled.
** For now, we provide stub implementations.
*/

/* Forward declaration of functions */
static CypherAst *cypherCreateTestAst(void);
static CypherAst *cypherAstCreateIdentifier(const char *zName, int nName, int iPos);

/* Parser state structure */
typedef struct CypherParseState {
  CypherParser *pParser;
  CypherAst *pResult;
  char *zError;
} CypherParseState;

/* Token constants are now defined in cypher-parser-generated.h */

/* Use generated Lemon functions */
#define CypherParseAlloc ParseAlloc
#define CypherParseFree ParseFree  
#define CypherParse Parse

/*
** Parser state structure used during parsing.
** Passed to all grammar rules via %extra_argument.
** (Already defined above as typedef)
*/

/*
** Create a new Cypher parser.
** Returns NULL on allocation failure.
*/
CypherParser *cypherParserCreate(sqlite3 *pDb) {
  CypherParser *pParser;
  
  pParser = sqlite3_malloc(sizeof(CypherParser));
  if( !pParser ) return NULL;
  
  memset(pParser, 0, sizeof(CypherParser));
  pParser->pDb = pDb;
  
  /* Create Lemon parser instance */
  pParser->pLemonParser = CypherParseAlloc(sqlite3_malloc);
  if( !pParser->pLemonParser ) {
    sqlite3_free(pParser);
    return NULL;
  }
  
  return pParser;
}

/*
** Destroy a Cypher parser and free all associated memory.
** Safe to call with NULL pointer.
*/
void cypherParserDestroy(CypherParser *pParser) {
  if( !pParser ) return;
  
  if( pParser->pLemonParser ) {
    CypherParseFree(pParser->pLemonParser, sqlite3_free);
  }
  
  if( pParser->pLexer ) {
    cypherLexerDestroy(pParser->pLexer);
  }
  
  if( pParser->pAst ) {
    cypherAstDestroy(pParser->pAst);
  }
  
  sqlite3_free(pParser->zErrorMsg);
  sqlite3_free(pParser);
}

/*
** Map Cypher token types to Lemon parser token constants.
** These constants are generated by Lemon from the grammar file.
*/
static int mapTokenToLemon(CypherTokenType tokenType) {
  switch( tokenType ) {
    case CYPHER_TOK_INTEGER:     return INTEGER;
    case CYPHER_TOK_FLOAT:       return FLOAT;
    case CYPHER_TOK_STRING:      return STRING;
    case CYPHER_TOK_BOOLEAN:     return BOOLEAN;
    case CYPHER_TOK_NULL:        return NULL_TOKEN;
    case CYPHER_TOK_IDENTIFIER:  return IDENTIFIER;
    case CYPHER_TOK_MATCH:       return MATCH;
    case CYPHER_TOK_WHERE:       return WHERE;
    case CYPHER_TOK_RETURN:      return RETURN;
    case CYPHER_TOK_CREATE:      return -1; /* Not in grammar */
    case CYPHER_TOK_MERGE:       return -1; /* Not in grammar */
    case CYPHER_TOK_SET:         return -1; /* Not in grammar */
    case CYPHER_TOK_DELETE:      return -1; /* Not in grammar */
    case CYPHER_TOK_REMOVE:      return -1; /* Not in grammar */
    case CYPHER_TOK_WITH:        return -1; /* Not in grammar */
    case CYPHER_TOK_ORDER:       return ORDER;
    case CYPHER_TOK_BY:          return BY;
    case CYPHER_TOK_LIMIT:       return LIMIT;
    case CYPHER_TOK_SKIP:        return SKIP;
    case CYPHER_TOK_AS:          return AS;
    case CYPHER_TOK_ASC:         return ASC;
    case CYPHER_TOK_DESC:        return DESC;
    case CYPHER_TOK_DISTINCT:    return DISTINCT;
    case CYPHER_TOK_OPTIONAL:    return OPTIONAL;
    case CYPHER_TOK_EQ:          return EQ;
    case CYPHER_TOK_NE:          return NE;
    case CYPHER_TOK_LT:          return LT;
    case CYPHER_TOK_LE:          return LE;
    case CYPHER_TOK_GT:          return GT;
    case CYPHER_TOK_GE:          return GE;
    case CYPHER_TOK_AND:         return AND;
    case CYPHER_TOK_OR:          return OR;
    case CYPHER_TOK_NOT:         return NOT;
    case CYPHER_TOK_PLUS:        return PLUS;
    case CYPHER_TOK_MINUS:       return MINUS;
    case CYPHER_TOK_MULT:        return MULT;
    case CYPHER_TOK_DIV:         return DIV;
    case CYPHER_TOK_LPAREN:      return LPAREN;
    case CYPHER_TOK_RPAREN:      return RPAREN;
    case CYPHER_TOK_LBRACKET:    return LBRACKET;
    case CYPHER_TOK_RBRACKET:    return RBRACKET;
    case CYPHER_TOK_LBRACE:      return -1; /* Not in grammar */
    case CYPHER_TOK_RBRACE:      return -1; /* Not in grammar */
    case CYPHER_TOK_COMMA:       return COMMA;
    case CYPHER_TOK_DOT:         return DOT;
    case CYPHER_TOK_COLON:       return COLON;
    case CYPHER_TOK_ARROW_LEFT:  return ARROW_LEFT;
    case CYPHER_TOK_ARROW_RIGHT: return ARROW_RIGHT;
    case CYPHER_TOK_DASH:        return DASH;
    case CYPHER_TOK_EOF:         return 0; /* End of input */
    default:                     return -1; /* Unknown token */
  }
}

/*
** Parse a Cypher query string.
** Returns SQLITE_OK on success, error code on failure.
*/
int cypherParserParse(CypherParser *pParser, const char *zQuery, int nQuery) {
  struct CypherParseState state;
  CypherToken *pToken;
  int rc = SQLITE_OK;
  
  if( !pParser || !zQuery ) return SQLITE_MISUSE;
  
  /* Clean up any previous parse state */
  if( pParser->pLexer ) {
    cypherLexerDestroy(pParser->pLexer);
    pParser->pLexer = NULL;
  }
  if( pParser->pAst ) {
    cypherAstDestroy(pParser->pAst);
    pParser->pAst = NULL;
  }
  sqlite3_free(pParser->zErrorMsg);
  pParser->zErrorMsg = NULL;
  pParser->nErrors = 0;
  
  /* Create lexer and tokenize input */
  pParser->pLexer = cypherLexerCreate(zQuery, nQuery);
  if( !pParser->pLexer ) {
    return SQLITE_NOMEM;
  }
  
  rc = cypherLexerTokenize(pParser->pLexer);
  if( rc != SQLITE_OK ) {
    pParser->zErrorMsg = sqlite3_mprintf("Lexical error: %s", 
                                        pParser->pLexer->zErrorMsg ? 
                                        pParser->pLexer->zErrorMsg : "Unknown error");
    return rc;
  }
  
  /* Initialize parse state */
  memset(&state, 0, sizeof(state));
  state.pParser = pParser;
  
  /* Feed tokens to parser */
  pToken = pParser->pLexer->pTokens;
  while( pToken && rc == SQLITE_OK ) {
    int lemonToken = mapTokenToLemon(pToken->type);
    
    if( lemonToken < 0 ) {
      pParser->zErrorMsg = sqlite3_mprintf("Unknown token type %d", pToken->type);
      rc = SQLITE_ERROR;
      break;
    }
    
    /* Skip whitespace and comment tokens */
    if( pToken->type == CYPHER_TOK_WHITESPACE || 
        pToken->type == CYPHER_TOK_COMMENT ) {
      pToken = pToken->pNext;
      continue;
    }
    
    /* Send token to parser */
    CypherParse(pParser->pLemonParser, lemonToken, pToken, &state);
    
    /* Check for parse errors */
    if( state.zError ) {
      pParser->zErrorMsg = state.zError;
      state.zError = NULL;
      pParser->nErrors++;
      rc = SQLITE_ERROR;
      break;
    }
    
    pToken = pToken->pNext;
  }
  
  /* Finalize parsing */
  if( rc == SQLITE_OK ) {
    CypherParse(pParser->pLemonParser, 0, NULL, &state); /* Signal end of input */
    
    if( state.zError ) {
      pParser->zErrorMsg = state.zError;
      pParser->nErrors++;
      rc = SQLITE_ERROR;
    } else if( state.pResult ) {
      pParser->pAst = state.pResult;
      
      /* Validate the AST */
      char *zValidationError = NULL;
      int rcValidation = cypherAstValidate(pParser->pAst, &zValidationError);
      if( rcValidation != SQLITE_OK ) {
        pParser->zErrorMsg = zValidationError;
        pParser->nErrors++;
        rc = rcValidation;
      }
    } else {
      pParser->zErrorMsg = sqlite3_mprintf("Parse completed but no AST generated");
      pParser->nErrors++;
      rc = SQLITE_ERROR;
    }
  }
  
  return rc;
}

/*
** Get the root AST node from a successful parse.
** Returns NULL if parsing failed or not yet performed.
*/
CypherAst *cypherParserGetAst(CypherParser *pParser) {
  return pParser ? pParser->pAst : NULL;
}

/*
** Get error message from parser.
** Returns NULL if no error occurred.
*/
const char *cypherParserGetError(CypherParser *pParser) {
  return pParser ? pParser->zErrorMsg : NULL;
}

/*
** Test function to parse a simple Cypher query and return string representation.
** This is useful for testing and debugging the parser.
** Caller must sqlite3_free() the returned string.
*/
char *cypherParseTestQuery(const char *zQuery) {
  CypherParser *pParser;
  char *zResult = NULL;
  int rc;
  
  pParser = cypherParserCreate(NULL);
  if( !pParser ) return NULL;
  
  rc = cypherParserParse(pParser, zQuery, -1);
  if( rc == SQLITE_OK && pParser->pAst ) {
    zResult = cypherAstToString(pParser->pAst);
  } else if( pParser->zErrorMsg ) {
    zResult = sqlite3_mprintf("ERROR: %s", pParser->zErrorMsg);
  } else {
    zResult = sqlite3_mprintf("ERROR: Unknown parse error");
  }
  
  cypherParserDestroy(pParser);
  return zResult;
}

/*
** Utility function to create a simple AST for testing.
** Creates a basic MATCH (n) RETURN n query AST.
*/
CypherAst *cypherCreateTestAst(void) {
  CypherAst *pQuery, *pSingleQuery, *pMatch, *pReturn;
  CypherAst *pPattern, *pNodePattern, *pProjection, *pProjectionItem;
  CypherAst *pIdentifier;
  
  /* Create AST nodes */
  pQuery = cypherAstCreate(CYPHER_AST_QUERY, 0, 0);
  pSingleQuery = cypherAstCreate(CYPHER_AST_SINGLE_QUERY, 0, 0);
  pMatch = cypherAstCreate(CYPHER_AST_MATCH, 1, 1);
  pReturn = cypherAstCreate(CYPHER_AST_RETURN, 1, 15);
  pPattern = cypherAstCreate(CYPHER_AST_NODE_PATTERN, 1, 7);
  pProjection = cypherAstCreate(CYPHER_AST_PROJECTION_LIST, 1, 22);
  pProjectionItem = cypherAstCreate(CYPHER_AST_PROJECTION_ITEM, 1, 22);
  
  if( !pQuery || !pSingleQuery || !pMatch || !pReturn || 
      !pPattern || !pProjection || !pProjectionItem ) {
    cypherAstDestroy(pQuery);
    cypherAstDestroy(pSingleQuery);
    cypherAstDestroy(pMatch);
    cypherAstDestroy(pReturn);
    cypherAstDestroy(pPattern);
    cypherAstDestroy(pProjection);
    cypherAstDestroy(pProjectionItem);
    return NULL;
  }
  
  /* Create identifiers */
  pIdentifier = cypherAstCreateIdentifier("n", 1, 8);
  if( !pIdentifier ) {
    cypherAstDestroy(pQuery);
    return NULL;
  }
  
  /* Build tree structure */
  cypherAstAddChild(pPattern, pIdentifier);
  cypherAstAddChild(pMatch, pPattern);
  
  pIdentifier = cypherAstCreateIdentifier("n", 1, 22);
  cypherAstAddChild(pProjectionItem, pIdentifier);
  cypherAstAddChild(pProjection, pProjectionItem);
  cypherAstAddChild(pReturn, pProjection);
  
  cypherAstAddChild(pSingleQuery, pMatch);
  cypherAstAddChild(pSingleQuery, pReturn);
  cypherAstAddChild(pQuery, pSingleQuery);
  
  return pQuery;
}

/*
** Stub implementation of cypherAstCreateIdentifier
*/
static CypherAst *cypherAstCreateIdentifier(const char *zName, int nName, int iPos) {
  CypherAst *pAst = sqlite3_malloc(sizeof(CypherAst));
  if( pAst ) {
    pAst->type = CYPHER_AST_IDENTIFIER;
    pAst->zValue = sqlite3_mprintf("%.*s", nName, zName);
    pAst->nChildren = 0;
    pAst->apChildren = 0;
  }
  return pAst;
}