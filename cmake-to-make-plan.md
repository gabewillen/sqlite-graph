# CMake to Makefile Migration Plan

## 1. Objective
To replace the existing CMake-based build system with a pure Makefile-based system, ensuring all project components (libraries, executables, tests) can be built, cleaned, and tested efficiently using `make`.

## 2. Rationale
*   Simplify the build process for developers familiar with Makefiles.
*   Potentially gain finer-grained control over compilation and linking.
*   Address persistent issues with CMake/Lemon integration.

## 3. High-Level Plan
1.  **Analyze Current CMake Setup:** Understand all targets, sources, dependencies, and flags.
2.  **Define Makefile Structure:** Create a hierarchical Makefile structure.
3.  **Translate Build Rules:** Convert CMake commands into Makefile syntax.
4.  **Manage Dependencies:** Implement proper `.PHONY` targets and dependency tracking.
5.  **Handle External Libraries:** Integrate SQLite and Unity build processes.
6.  **Implement Test and Clean Targets.**
7.  **Verify Build:** Ensure the new Makefile system builds the project correctly.

## 4. Detailed Plan & TODOs

### 4.1. Project Structure Overview
*   `Makefile`: Main entry point, orchestrates sub-Makefiles.
*   `src/Makefile`: Builds `libgraph.so` and `libgraph_static.a`.
*   `tests/Makefile`: Builds and runs test executables.
*   `grammar/Makefile`: (Already exists) Generates parser files from `cypher.lemon`.
*   `build/`: Directory for all compiled artifacts (object files, libraries, executables).

### 4.2. Main `Makefile` (`./Makefile`)
*   **Variables:** Define common variables like `CC`, `CFLAGS`, `LDFLAGS`, `BUILD_DIR`.
*   **Targets:**
    *   `all`: Default target, builds everything.
    *   `clean`: Cleans all build artifacts.
    *   `test`: Runs all tests.
    *   `rebuild`: Cleans and then builds.
*   **Sub-Makefile Inclusion:** Use `include` or `$(MAKE) -C` for sub-Makefiles.

**TODOs for `./Makefile`:**
- [ ] Define `CC`, `CFLAGS`, `LDFLAGS` variables.
- [ ] Define `BUILD_DIR = build`.
- [ ] Create `all` target that calls `$(MAKE) -C src`, `$(MAKE) -C tests`.
- [ ] Create `clean` target that calls `$(MAKE) -C src clean`, `$(MAKE) -C tests clean`, `$(MAKE) -C grammar clean`, and `rm -rf $(BUILD_DIR)`.
- [ ] Create `test` target that calls `$(MAKE) -C tests test`.
- [ ] Create `rebuild` target.
- [ ] Add `.PHONY` declarations for `all`, `clean`, `test`, `rebuild`.

### 4.3. Source Makefile (`src/Makefile`)
*   **Variables:** `SRCS`, `OBJS`, `INCLUDES`, `LIBS`.
*   **Targets:** `libgraph.so`, `libgraph_static.a`, object files.
*   **Compilation Rules:** Generic rules for `.c` to `.o`.
*   **Linking Rules:** For shared and static libraries.

**TODOs for `src/Makefile`:**
- [ ] Define `SRCS` for all `.c` files in `src/` and `src/cypher/`.
- [ ] Define `OBJS` based on `SRCS` (e.g., `$(patsubst %.c,$(BUILD_DIR)/%.o,$(SRCS))`).
- [ ] Define `INCLUDES` for `include/` and external libraries (SQLite).
- [ ] Define `LIBS` for `m` (math library).
- [ ] Create a rule to build `$(BUILD_DIR)/libgraph.so` from `OBJS`.
- [ ] Create a rule to build `$(BUILD_DIR)/libgraph_static.a` from `OBJS`.
- [ ] Implement generic compilation rule `$(BUILD_DIR)/%.o: %.c`.
- [ ] Ensure `cypher/cypher-parser-generated.c` is generated by `grammar/Makefile` before compilation.
- [ ] Add specific compile flags for `cypher/cypher-parser-generated.c` (`-Wno-unused-parameter;-Wno-unused-variable`).
- [ ] Add `SQLITE_CORE` definition for `graph_static`.
- [ ] Add `clean` target to remove object files and libraries.

### 4.4. Tests Makefile (`tests/Makefile`)
*   **Variables:** `TEST_SRCS`, `TEST_OBJS`, `TEST_EXES`.
*   **Targets:** Test executables, `test` target.
*   **Linking:** Link against `libgraph_static.a` and Unity.

**TODOs for `tests/Makefile`:**
- [ ] Define `TEST_SRCS` for all `.c` files in `tests/`.
- [ ] Define `TEST_OBJS` and `TEST_EXES`.
- [ ] Implement generic compilation rule for test object files.
- [ ] Create rules to link each `TEST_EXE`.
- [ ] Ensure linking against `$(BUILD_DIR)/libgraph_static.a` and Unity library.
- [ ] Create `test` target to run all `TEST_EXES`.
- [ ] Add `clean` target to remove test object files and executables.

### 4.5. External Dependencies (SQLite and Unity)
*   **Current CMake:** Uses `FetchContent` to download and build.
*   **Makefile Approach:**
    *   Option A: Assume system-installed versions (simpler, but less portable).
    *   Option B: Manual download and compilation within the Makefile (more complex, but self-contained).
    *   Option C: Use `git submodule` for source and build them as part of the main Makefile.

**TODOs for External Dependencies:**
- [ ] **Decision:** Choose one of Option A, B, or C. (Suggesting Option C for better control and reproducibility).
- [ ] If Option C: Add `sqlite3` and `Unity` as git submodules.
- [ ] If Option C: Create rules in `src/Makefile` (or a separate `external/Makefile`) to build `sqlite3.c` into `libsqlite3_lib.a`.
- [ ] If Option C: Create rules to build Unity framework.
- [ ] Ensure correct include paths and linking for these libraries.

### 4.6. Grammar Makefile (`grammar/Makefile`)
*   (Already exists, ensure it's called by the main Makefile or `src/Makefile`)

**TODOs for `grammar/Makefile`:**
- [ ] Verify `grammar/Makefile` correctly generates `cypher.c` and `cypher.h`.
- [ ] Ensure `src/Makefile` has a dependency on these generated files.

### 4.7. Verification
- [ ] Run `make` from the project root.
- [ ] Run `make test`.
- [ ] Run `make clean`.
- [ ] Check for any compilation warnings or errors.
- [ ] Ensure all expected binaries and libraries are created.

## 5. Risks & Mitigation
*   **Complexity:** Makefiles can become complex for large projects. Mitigation: Keep them modular and use common patterns.
*   **Portability:** Makefiles can be less portable than CMake. Mitigation: Stick to standard Makefile features and shell commands.
*   **Dependency Tracking:** Incorrect dependencies can lead to stale builds. Mitigation: Use automatic dependency generation (`-MMD -MP` with GCC/Clang).

This plan provides a structured approach to migrating from CMake to Makefiles. The next step would be to start implementing these Makefiles incrementally, testing each component as it's built.