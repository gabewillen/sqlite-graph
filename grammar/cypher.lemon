/*
** SQLite Graph Database Extension - Cypher Grammar (Lemon)
**
** This file defines the grammar for parsing openCypher queries using
** the Lemon parser generator. This grammar covers the core Cypher
** language constructs needed for basic graph querying.
**
** The grammar follows openCypher specification patterns and produces
** an abstract syntax tree (AST) for query planning and execution.
**
** Memory management: All AST nodes use sqlite3_malloc()/sqlite3_free()
** Error handling: Parse errors are reported through parser context
*/

%include {
#include "cypher.h"
#include <string.h>
#include <assert.h>

/* Parser state structure passed to all grammar rules */
struct CypherParseState {
  CypherParser *pParser;
  CypherAst *pResult;
  char *zError;
};

/* Forward declarations for AST functions */
CypherAst *cypherAstCreateIdentifier(const char *zName, int iLine, int iColumn);
CypherAst *cypherAstCreateLiteral(const char *zValue, int iLine, int iColumn);
CypherAst *cypherAstCreateBinaryOp(const char *zOp, CypherAst *pLeft, CypherAst *pRight, int iLine, int iColumn);
CypherAst *cypherAstCreateProperty(CypherAst *pObj, const char *zProp, int iLine, int iColumn);
}

%token_type {CypherToken*}
%default_type {CypherAst*}
%extra_argument {struct CypherParseState *pState}
%start_symbol cypher_query

%token CREATE
%token MERGE
%token SET
%token DELETE
%token REMOVE
%token WITH
%token LBRACE
%token RBRACE
%token INTEGER
%token FLOAT
%token STRING
%token BOOLEAN
%token UNION
%token MATCH
%token OPTIONAL
%token COMMA
%token LPAREN
%token RPAREN
%token IDENTIFIER
%token COLON
%token DASH
%token LBRACKET
%token RBRACKET
%token ARROW_RIGHT
%token ARROW_LEFT
%token WHERE
%token RETURN
%token DISTINCT
%token AS
%token ORDER
%token BY
%token ASC
%token DESC
%token LIMIT
%token SKIP
%token OR
%token AND
%token EQ
%token NE
%token LT
%token LE
%token GT
%token GE
%token PLUS
%token MINUS
%token MULT
%token DIV
%token NOT
%token DOT
%token KW_NULL

%syntax_error {
  pState->zError = (char*)"Syntax error in Cypher query";
}

%parse_failure {
  pState->zError = (char*)"Parser failed due to stack overflow";
}

/*
** Top-level query rule
*/
cypher_query(Q) ::= query(SQ) . {
  Q = SQ;
  pState->pResult = Q;
}

query(Q) ::= single_query(SQ) . {
  Q = cypherAstCreate(CYPHER_AST_QUERY, 0, 0);
  if( Q ) cypherAstAddChild(Q, SQ);
}

query(Q) ::= union_query(UQ) . {
  Q = UQ;
}

union_query(Q) ::= single_query(SQ1) UNION single_query(SQ2) . {
  Q = cypherAstCreate(CYPHER_AST_UNION, 0, 0);
  if( Q ) {
    cypherAstAddChild(Q, SQ1);
    cypherAstAddChild(Q, SQ2);
  }
}

union_query(Q) ::= union_query(UQ) UNION single_query(SQ) . {
  if( UQ ) {
    cypherAstAddChild(UQ, SQ);
    Q = UQ;
  }
}

/*
** Single query without UNION
*/
single_query(SQ) ::= reading_clause_list(RCL) return_clause(RC) . {
  SQ = cypherAstCreate(CYPHER_AST_SINGLE_QUERY, 0, 0);
  if( SQ ) {
    cypherAstAddChild(SQ, RCL);
    cypherAstAddChild(SQ, RC);
  }
}

single_query(SQ) ::= reading_clause_list(RCL) return_clause(RC) order_by_clause(OB) . {
  SQ = cypherAstCreate(CYPHER_AST_SINGLE_QUERY, 0, 0);
  if( SQ ) {
    cypherAstAddChild(SQ, RCL);
    cypherAstAddChild(SQ, RC);
    cypherAstAddChild(SQ, OB);
  }
}

single_query(SQ) ::= reading_clause_list(RCL) return_clause(RC) limit_clause(LC) . {
  SQ = cypherAstCreate(CYPHER_AST_SINGLE_QUERY, 0, 0);
  if( SQ ) {
    cypherAstAddChild(SQ, RCL);
    cypherAstAddChild(SQ, RC);
    cypherAstAddChild(SQ, LC);
  }
}

single_query(SQ) ::= reading_clause_list(RCL) return_clause(RC) skip_clause(SC) . {
  SQ = cypherAstCreate(CYPHER_AST_SINGLE_QUERY, 0, 0);
  if( SQ ) {
    cypherAstAddChild(SQ, RCL);
    cypherAstAddChild(SQ, RC);
    cypherAstAddChild(SQ, SC);
  }
}

/*
** Reading clauses (MATCH, WHERE, etc.)
*/
reading_clause_list(RCL) ::= reading_clause(RC) . {
  RCL = RC;
}

reading_clause_list(RCL) ::= reading_clause_list(RCL1) reading_clause(RC) . {
  /* Create a list node if needed */
  if( RCL1 ) {
    cypherAstAddChild(RCL1, RC);
    RCL = RCL1;
  } else {
    RCL = RC;
  }
}

reading_clause(RC) ::= match_clause(MC) . { RC = MC; }
reading_clause(RC) ::= where_clause(WC) . { RC = WC; }

/*
** MATCH clause
*/
match_clause(MC) ::= MATCH(M) pattern_list(PL) . {
  MC = cypherAstCreate(CYPHER_AST_MATCH, M->iLine, M->iColumn);
  if( MC ) cypherAstAddChild(MC, PL);
}

match_clause(MC) ::= OPTIONAL(O) MATCH pattern_list(PL) . {
  MC = cypherAstCreate(CYPHER_AST_OPTIONAL_MATCH, O->iLine, O->iColumn);
  if( MC ) cypherAstAddChild(MC, PL);
}

/*
** Pattern list
*/
pattern_list(PL) ::= pattern(P) . { PL = P; }
pattern_list(PL) ::= pattern_list(PL1) COMMA pattern(P) . {
  if( PL1 ) {
    cypherAstAddChild(PL1, P);
    PL = PL1;
  } else {
    PL = P;
  }
}

/*
** Pattern (simplified for basic queries)
*/
pattern(P) ::= node_pattern(NP) . { P = NP; }
pattern(P) ::= node_pattern(NP1) relationship_pattern(RP) node_pattern(NP2) . {
  P = cypherAstCreate(CYPHER_AST_PATH, 0, 0);
  if( P ) {
    cypherAstAddChild(P, NP1);
    cypherAstAddChild(P, RP);
    cypherAstAddChild(P, NP2);
  }
}

/*
** Node pattern: (n), (n:Label), (n:Label {prop: value})
*/
node_pattern(NP) ::= LPAREN RPAREN . {
  NP = cypherAstCreate(CYPHER_AST_NODE_PATTERN, 0, 0);
}

node_pattern(NP) ::= LPAREN IDENTIFIER(ID) RPAREN . {
  NP = cypherAstCreate(CYPHER_AST_NODE_PATTERN, 0, 0);
  if( NP ) {
    CypherAst *pId = cypherAstCreateIdentifier(ID->zValue, ID->iLine, ID->iColumn);
    if( pId ) cypherAstAddChild(NP, pId);
  }
}

node_pattern(NP) ::= LPAREN IDENTIFIER(ID) node_labels(NL) RPAREN . {
  NP = cypherAstCreate(CYPHER_AST_NODE_PATTERN, 0, 0);
  if( NP ) {
    CypherAst *pId = cypherAstCreateIdentifier(ID->zValue, ID->iLine, ID->iColumn);
    if( pId ) cypherAstAddChild(NP, pId);
    cypherAstAddChild(NP, NL);
  }
}

/*
** Node labels: :Label or :Label1:Label2
*/
node_labels(NL) ::= COLON IDENTIFIER(ID) . {
  NL = cypherAstCreate(CYPHER_AST_LABELS, 0, 0);
  if( NL ) {
    CypherAst *pLabel = cypherAstCreateIdentifier(ID->zValue, ID->iLine, ID->iColumn);
    if( pLabel ) cypherAstAddChild(NL, pLabel);
  }
}



/*
** Relationship pattern: -[r]-, -[r:TYPE]-, -[r:TYPE]->
*/
relationship_pattern(RP) ::= DASH LBRACKET RBRACKET DASH . {
  RP = cypherAstCreate(CYPHER_AST_REL_PATTERN, 0, 0);
}

relationship_pattern(RP) ::= DASH LBRACKET IDENTIFIER(ID) RBRACKET DASH . {
  RP = cypherAstCreate(CYPHER_AST_REL_PATTERN, 0, 0);
  if( RP ) {
    CypherAst *pId = cypherAstCreateIdentifier(ID->zValue, ID->iLine, ID->iColumn);
    if( pId ) cypherAstAddChild(RP, pId);
  }
}

relationship_pattern(RP) ::= DASH LBRACKET IDENTIFIER(ID) COLON IDENTIFIER(TYPE) RBRACKET DASH . {
  RP = cypherAstCreate(CYPHER_AST_REL_PATTERN, 0, 0);
  if( RP ) {
    CypherAst *pId = cypherAstCreateIdentifier(ID->zValue, ID->iLine, ID->iColumn);
    CypherAst *pType = cypherAstCreateIdentifier(TYPE->zValue, TYPE->iLine, TYPE->iColumn);
    if( pId && pType ) {
      cypherAstAddChild(RP, pId);
      cypherAstAddChild(RP, pType);
    }
  }
}

relationship_pattern(RP) ::= DASH LBRACKET IDENTIFIER(ID) COLON IDENTIFIER(TYPE) RBRACKET ARROW_RIGHT . {
  RP = cypherAstCreate(CYPHER_AST_REL_PATTERN, 0, 0);
  if( RP ) {
    CypherAst *pId = cypherAstCreateIdentifier(ID->zValue, ID->iLine, ID->iColumn);
    if( pId ) cypherAstAddChild(RP, pId);
    cypherAstAddChild(RP, pType);
  }
}

relationship_pattern(RP) ::= ARROW_LEFT LBRACKET IDENTIFIER(ID) COLON IDENTIFIER(TYPE) RBRACKET DASH . {
  RP = cypherAstCreate(CYPHER_AST_REL_PATTERN, 0, 0);
  if( RP ) {
    CypherAst *pId = cypherAstCreateIdentifier(ID->zValue, ID->iLine, ID->iColumn);
    if( pId ) cypherAstAddChild(RP, pId);
    cypherAstAddChild(RP, pType);
  }
}

where_clause(WC) ::= WHERE expression(E) . {
  WC = cypherAstCreate(CYPHER_AST_WHERE, 0, 0);
  if( WC ) cypherAstAddChild(WC, E);
}

return_clause(RC) ::= RETURN projection_list(PL) . {
  RC = cypherAstCreate(CYPHER_AST_RETURN, 0, 0);
  if( RC ) {
    cypherAstAddChild(RC, PL);
  }
}

return_clause(RC) ::= RETURN DISTINCT projection_list(PL) . {
  RC = cypherAstCreate(CYPHER_AST_RETURN, 0, 0);
  if( RC ) {
    cypherAstAddChild(RC, PL);
    /* Set DISTINCT flag */
    RC->iFlags |= 1;
  }
}

projection_list(PL) ::= projection_item(PI) . {
  PL = cypherAstCreate(CYPHER_AST_PROJECTION_LIST, 0, 0);
  if( PL ) cypherAstAddChild(PL, PI);
}

projection_list(PL) ::= projection_list(PL1) COMMA projection_item(PI) . {
  if( PL1 ) {
    cypherAstAddChild(PL1, PI);
    PL = PL1;
  }
}

projection_item(PI) ::= expression(E) . {
  PI = cypherAstCreate(CYPHER_AST_PROJECTION_ITEM, 0, 0);
  if( PI ) {
    cypherAstAddChild(PI, E);
  }
}

projection_item(PI) ::= expression(E) AS IDENTIFIER(ID) . {
  PI = cypherAstCreate(CYPHER_AST_PROJECTION_ITEM, 0, 0);
  if( PI ) {
    cypherAstAddChild(PI, E);
    CypherAst *pAlias = cypherAstCreateIdentifier(ID->zValue, ID->iLine, ID->iColumn);
    if( pAlias ) cypherAstAddChild(PI, pAlias);
  }
}

order_by_clause(OB) ::= ORDER BY sort_list(SL) . {
  OB = cypherAstCreate(CYPHER_AST_ORDER_BY, 0, 0);
  if( OB ) {
    cypherAstAddChild(OB, SL);
  }
}

sort_list(SL) ::= sort_item(SI) . {
  SL = cypherAstCreate(CYPHER_AST_SORT_LIST, 0, 0);
  if( SL ) {
    cypherAstAddChild(SL, SI);
  }
}

sort_list(SL) ::= sort_list(SL1) COMMA sort_item(SI) . {
  if( SL1 ) {
    cypherAstAddChild(SL1, SI);
    SL = SL1;
  }
}

sort_item(SI) ::= expression(E) . {
  SI = cypherAstCreate(CYPHER_AST_SORT_ITEM, 0, 0);
  if( SI ) {
    cypherAstAddChild(SI, E);
  }
}

sort_item(SI) ::= expression(E) ASC . {
  SI = cypherAstCreate(CYPHER_AST_SORT_ITEM, 0, 0);
  if( SI ) {
    cypherAstAddChild(SI, E);
    cypherAstSetValue(SI, "ASC");
  }
}

sort_item(SI) ::= expression(E) DESC . {
  SI = cypherAstCreate(CYPHER_AST_SORT_ITEM, 0, 0);
  if( SI ) {
    cypherAstAddChild(SI, E);
    cypherAstSetValue(SI, "DESC");
  }
}

limit_clause(LC) ::= LIMIT INTEGER(I) . {
  LC = cypherAstCreate(CYPHER_AST_LIMIT, 0, 0);
  if( LC ) {
    CypherAst *pLimit = cypherAstCreateLiteral(I->zValue, I->iLine, I->iColumn);
    if( pLimit ) cypherAstAddChild(LC, pLimit);
  }
}

skip_clause(SC) ::= SKIP INTEGER(I) . {
  SC = cypherAstCreate(CYPHER_AST_SKIP, 0, 0);
  if( SC ) {
    CypherAst *pSkip = cypherAstCreateLiteral(I->zValue, I->iLine, I->iColumn);
    if( pSkip ) cypherAstAddChild(SC, pSkip);
  }
}

expression(E) ::= or_expression(OE) . { E = OE; }

or_expression(E) ::= and_expression(AE) . { E = AE; }
or_expression(E) ::= or_expression(E1) OR and_expression(AE) . {
  E = cypherAstCreateBinaryOp("OR", E1, AE, 0, 0);
}

and_expression(E) ::= equality_expression(EE) . { E = EE; }
and_expression(E) ::= and_expression(E1) AND equality_expression(EE) . {
  E = cypherAstCreateBinaryOp("AND", E1, EE, 0, 0);
}

equality_expression(E) ::= relational_expression(RE) . { E = RE; }
equality_expression(E) ::= equality_expression(E1) EQ relational_expression(RE) . {
  E = cypherAstCreateBinaryOp("=", E1, RE, 0, 0);
}
equality_expression(E) ::= equality_expression(E1) NE relational_expression(RE) . {
  E = cypherAstCreateBinaryOp("<>", E1, RE, 0, 0);
}

relational_expression(E) ::= additive_expression(AE) . { E = AE; }
relational_expression(E) ::= relational_expression(E1) LT additive_expression(AE) . {
  E = cypherAstCreateBinaryOp("<", E1, AE, 0, 0);
}
relational_expression(E) ::= relational_expression(E1) LE additive_expression(AE) . {
  E = cypherAstCreateBinaryOp("<=", E1, AE, 0, 0);
}
relational_expression(E) ::= relational_expression(E1) GT additive_expression(AE) . {
  E = cypherAstCreateBinaryOp(">", E1, AE, 0, 0);
}
relational_expression(E) ::= relational_expression(E1) GE additive_expression(AE) . {
  E = cypherAstCreateBinaryOp(">=", E1, AE, 0, 0);
}

additive_expression(E) ::= multiplicative_expression(ME) . { E = ME; }
additive_expression(E) ::= additive_expression(E1) PLUS multiplicative_expression(ME) . {
  E = cypherAstCreateBinaryOp("+", E1, ME, 0, 0);
}
additive_expression(E) ::= additive_expression(E1) MINUS multiplicative_expression(ME) . {
  E = cypherAstCreateBinaryOp("-", E1, ME, 0, 0);
}

multiplicative_expression(E) ::= unary_expression(UE) . { E = UE; }
multiplicative_expression(E) ::= multiplicative_expression(E1) MULT unary_expression(UE) . {
  E = cypherAstCreateBinaryOp("*", E1, UE, 0, 0);
}
multiplicative_expression(E) ::= multiplicative_expression(E1) DIV unary_expression(UE) . {
  E = cypherAstCreateBinaryOp("/", E1, UE, 0, 0);
}

unary_expression(E) ::= primary_expression(PE) . { E = PE; }
unary_expression(E) ::= NOT primary_expression(PE) . {
  E = cypherAstCreate(CYPHER_AST_UNARY_OP, 0, 0);
  if( E ) {
    cypherAstSetValue(E, "NOT");
    cypherAstAddChild(E, PE);
  }
}
unary_expression(E) ::= MINUS primary_expression(PE) . {
  E = cypherAstCreate(CYPHER_AST_UNARY_OP, 0, 0);
  if( E ) {
    cypherAstSetValue(E, "-");
    cypherAstAddChild(E, PE);
  }
}

primary_expression(E) ::= literal(L) . { E = L; }
primary_expression(E) ::= IDENTIFIER(ID) . {
  E = cypherAstCreateIdentifier(ID->zValue, ID->iLine, ID->iColumn);
}
primary_expression(E) ::= property_expression(PE) . { E = PE; }
primary_expression(E) ::= LPAREN expression(EX) RPAREN . {
  E = EX;
}

property_expression(E) ::= IDENTIFIER(ID) DOT IDENTIFIER(PROP) . {
  CypherAst *pObj = cypherAstCreateIdentifier(ID->zValue, ID->iLine, ID->iColumn);
  E = cypherAstCreateProperty(pObj, PROP->zValue, PROP->iLine, PROP->iColumn);
}

literal(L) ::= INTEGER(I) . {
  L = cypherAstCreateLiteral(I->zValue, I->iLine, I->iColumn);
}
literal(L) ::= FLOAT(F) . {
  L = cypherAstCreateLiteral(F->zValue, F->iLine, F->iColumn);
}
literal(L) ::= STRING(S) . {
  L = cypherAstCreateLiteral(S->zValue, S->iLine, S->iColumn);
}
literal(L) ::= BOOLEAN(B) . {
  L = cypherAstCreateLiteral(B->zValue, B->iLine, B->iColumn);
}
literal(L) ::= KW_NULL . {
  L = cypherAstCreateLiteral("null", 0, 0);
}
